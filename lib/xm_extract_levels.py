########################################################################
########################################################################
"""
xm_extract_levels.py

Description: This script takes a level file as input to group all kmer 
observations into respective bins. The input file for this script is
generated by xenomorph.py preprocess. Output file contains a list of all 
possible kmers and all observed normalized signal levels. This output can
be used to build models or plotted to look at kmer statistics. 

Cite us: 

H. Kawabe, C. Thomas, S. Hoshika, Myong-Jung Kim, Myong-Sang Kim, L. Miessner, N. Kaplan, J. M. Craig, 
J. Gundlach, A. Laszlo,  S. A. Benner, J. A. Marchand. "Enzymatic Synthesis and Nanopore Sequencing of a 12-Letter Supernumerary DNA" 
Nature Communications. 14. (2023). DOI: 10.1038/s41467-023-42406-z 


Updated: 9/7/23
"""
########################################################################
########################################################################



from Bio.Seq import Seq
import sys 
import numpy as np
import pandas as pd
import itertools 
import os
#from tombo import tombo_helper, tombo_stats, resquiggle
from string import ascii_lowercase
from alive_progress import alive_bar
from xm_params import * 

if __name__ == '__main__': 
	def seq2kmer(seq, k):
		kmers = []
		for i in range(0,len(seq)-k+1):
		    kmers.append(seq[i:i+k].upper())
		return kmers

	def readlevel2kmerlevel(read_level, kmer_mask): 
		z_pos = kmer_mask.find('x')
		read_level = read_level.replace('\n',' ').replace("'",'').replace(']','').replace('[','').split(' ')
		read_level = [i for i in read_level if i]
		read_level_kmers = read_level[z_pos:len(read_level)-len(kmer_mask[z_pos:-1])]
		return read_level_kmers


	#Input level file from preprocess
	level_input_file = sys.argv[1]
	output_file = level_input_file.replace('levels.csv','')+'kmers.csv'


	#Open level file as pandas dataframe
	level_file = pd.read_csv(level_input_file) 

	#Generate pandas dataframe with every possible kmer [kmer, data] 
	kmer_b=[] 
	kmer_size =4 
	bases =list(set(''.join(level_file['read_xna_sequence'].to_list())))
	kmers = list(set([''.join(i) for i in itertools.product(bases, repeat = kmer_size)]))
	kmers.sort()

	#Generate output dataframe and configure 
	np.set_printoptions(threshold=sys.maxsize)
	pd.set_option('display.float_format', lambda x: '%.4f' % x)
	bskmer_level = pd.DataFrame({'kmer_xy' : kmers})
	bskmer_level['mean_level']=''
	bskmer_level['mean_level']=bskmer_level['mean_level'].astype(object)

	print('Xenomorph Status - [Model building] Note: read filtering options are enabled')
	#Loop through all files 
	with alive_bar(len(level_file), force_tty=True) as bar: 
		for i in range(0,len(level_file)): 
		    bar()
		    seq =level_file.iloc[i]['read_xna_sequence']
		    level = level_file.iloc[i]['read_levels']
		    qscore = level_file.iloc[i]['read_q-score']
		    #sscore = level_file.iloc[i]['read_signal_match_score']
		    sscore = 0.5
		
		    if qscore > qscore_filter and sscore < signal_filter: 

		        kmer_seq = seq2kmer(seq,4)
		        levels = readlevel2kmerlevel(level, kmer_mask[0])


		        for j in range(0,len(kmer_seq)):
		            sel_kmer = kmer_seq[j]
		            levo = bskmer_level.loc[bskmer_level['kmer_xy']==sel_kmer, 'mean_level'].values[0]

		            lev = np.array(levels[j])


		            if len(str(levo))>0:
		                lev = np.array(lev)
		                levo = np.array(levo)
		                lev = np.append(lev,levo)

		            else:
		                lev=np.array(str(lev))

		            bskmer_level.at[bskmer_level[bskmer_level['kmer_xy']==sel_kmer].index[0], 'mean_level'] = lev



	#Save open save to drop na rows 
	bskmer_level.to_csv(output_file)
	bskmer_level=pd.read_csv(output_file)
	bskmer_level['mean_level'].replace('', np.nan, inplace=True)
	bskmer_level.dropna(subset=['mean_level'], inplace=True)
	bskmer_level.to_csv(output_file)










